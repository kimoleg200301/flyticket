{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */function (_super) {\n  __extends(PDFParser, _super);\n  function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    if (objectsPerTick === void 0) {\n      objectsPerTick = Infinity;\n    }\n    if (throwOnInvalidObject === void 0) {\n      throwOnInvalidObject = false;\n    }\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n    _this.alreadyParsed = false;\n    _this.parsedObjects = 0;\n    _this.shouldWaitForTick = function () {\n      _this.parsedObjects += 1;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    _this.objectsPerTick = objectsPerTick;\n    _this.throwOnInvalidObject = throwOnInvalidObject;\n    return _this;\n  }\n  PDFParser.prototype.parseDocument = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var prevOffset, offset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new ReparseError('PDFParser', 'parseDocument');\n            }\n            this.alreadyParsed = true;\n            this.context.header = this.parseHeader();\n            _a.label = 1;\n          case 1:\n            if (!!this.bytes.done()) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.parseDocumentSection()];\n          case 2:\n            _a.sent();\n            offset = this.bytes.offset();\n            if (offset === prevOffset) {\n              throw new StalledParserError(this.bytes.position());\n            }\n            prevOffset = offset;\n            return [3 /*break*/, 1];\n          case 3:\n            this.maybeRecoverRoot();\n            if (this.context.lookup(PDFRef.of(0))) {\n              console.warn('Removing parsed object: 0 0 R');\n              this.context.delete(PDFRef.of(0));\n            }\n            return [2 /*return*/, this.context];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeRecoverRoot = function () {\n    var isValidCatalog = function (obj) {\n      return obj instanceof PDFDict && obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n    };\n    var catalog = this.context.lookup(this.context.trailerInfo.Root);\n    if (!isValidCatalog(catalog)) {\n      var indirectObjects = this.context.enumerateIndirectObjects();\n      for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        var _a = indirectObjects[idx],\n          ref = _a[0],\n          object = _a[1];\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  };\n  PDFParser.prototype.parseHeader = function () {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.header)) {\n        var major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes.Period);\n        var minor = this.parseRawInt();\n        var header = PDFHeader.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n      this.bytes.next();\n    }\n    throw new MissingPDFHeaderError(this.bytes.position());\n  };\n  PDFParser.prototype.parseIndirectObjectHeader = function () {\n    this.skipWhitespaceAndComments();\n    var objectNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    var generationNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.obj)) {\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n    }\n    return PDFRef.of(objectNumber, generationNumber);\n  };\n  PDFParser.prototype.matchIndirectObjectHeader = function () {\n    var initialOffset = this.bytes.offset();\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  };\n  PDFParser.prototype.parseIndirectObject = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ref, object;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ref = this.parseIndirectObjectHeader();\n            this.skipWhitespaceAndComments();\n            object = this.parseObject();\n            this.skipWhitespaceAndComments();\n            // if (!this.matchKeyword(Keywords.endobj)) {\n            // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n            // }\n            // TODO: Log a warning if this fails...\n            this.matchKeyword(Keywords.endobj);\n            if (!(object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n            return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            if (object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n              PDFXRefStreamParser.forStream(object).parseIntoContext();\n            } else {\n              this.context.assign(ref, object);\n            }\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, ref];\n        }\n      });\n    });\n  };\n  // TODO: Improve and clean this up\n  PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n    var startPos = this.bytes.position();\n    var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n    var ref = this.parseIndirectObjectHeader();\n    console.warn(\"Invalid object ref: \" + ref);\n    this.skipWhitespaceAndComments();\n    var start = this.bytes.offset();\n    var failed = true;\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.endobj)) {\n        failed = false;\n      }\n      if (!failed) break;\n      this.bytes.next();\n    }\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\n    var end = this.bytes.offset() - Keywords.endobj.length;\n    var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n    return ref;\n  };\n  PDFParser.prototype.parseIndirectObjects = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var initialOffset, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.skipWhitespaceAndComments();\n            _a.label = 1;\n          case 1:\n            if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n            initialOffset = this.bytes.offset();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.parseIndirectObject()];\n          case 3:\n            _a.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            e_1 = _a.sent();\n            // TODO: Add tracing/logging mechanism to track when this happens!\n            this.bytes.moveTo(initialOffset);\n            this.tryToParseInvalidIndirectObject();\n            return [3 /*break*/, 5];\n          case 5:\n            this.skipWhitespaceAndComments();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n            return [4 /*yield*/, waitForTick()];\n          case 6:\n            _a.sent();\n            _a.label = 7;\n          case 7:\n            return [3 /*break*/, 1];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeParseCrossRefSection = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n    var objectNumber = -1;\n    var xref = PDFCrossRefSection.createEmpty();\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      var firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var byte = this.bytes.peek();\n      if (byte === CharCodes.n || byte === CharCodes.f) {\n        var ref = PDFRef.of(objectNumber, secondInt);\n        if (this.bytes.next() === CharCodes.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n      this.skipWhitespaceAndComments();\n    }\n    return xref;\n  };\n  PDFParser.prototype.maybeParseTrailerDict = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n    var dict = this.parseDict();\n    var context = this.context;\n    context.trailerInfo = {\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID\n    };\n  };\n  PDFParser.prototype.maybeParseTrailer = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n    var offset = this.parseRawInt();\n    this.skipWhitespace();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\n  };\n  PDFParser.prototype.parseDocumentSection = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.parseIndirectObjects()];\n          case 1:\n            _a.sent();\n            this.maybeParseCrossRefSection();\n            this.maybeParseTrailerDict();\n            this.maybeParseTrailer();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\r\n   * contain jibberish in between indirect objects. This method is designed to\r\n   * skip past that jibberish, should it exist, until it reaches the next\r\n   * indirect object header, an xref table section, or the file trailer.\r\n   */\n  PDFParser.prototype.skipJibberish = function () {\n    this.skipWhitespaceAndComments();\n    while (!this.bytes.done()) {\n      var initialOffset = this.bytes.offset();\n      var byte = this.bytes.peek();\n      var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n      if (isAlphaNumeric) {\n        if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n      this.bytes.next();\n    }\n  };\n  /**\r\n   * Skips the binary comment following a PDF header. The specification\r\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\r\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\r\n   *\r\n   * This would imply that to strip out this binary comment, we could check for\r\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\r\n   * are 128 or greater. This works for many documents that properly comply with\r\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\r\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\r\n   * these headers correctly, we just throw out all bytes leading up to the\r\n   * first indirect object header.\r\n   */\n  PDFParser.prototype.skipBinaryHeaderComment = function () {\n    this.skipWhitespaceAndComments();\n    try {\n      var initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  };\n  PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n  };\n  return PDFParser;\n}(PDFObjectParser);\nexport default PDFParser;","map":{"version":3,"names":["PDFCrossRefSection","PDFHeader","PDFTrailer","MissingKeywordError","MissingPDFHeaderError","PDFInvalidObjectParsingError","ReparseError","StalledParserError","PDFDict","PDFInvalidObject","PDFName","PDFRawStream","PDFRef","ByteStream","PDFObjectParser","PDFObjectStreamParser","PDFXRefStreamParser","PDFContext","CharCodes","Keywords","IsDigit","waitForTick","PDFParser","_super","__extends","pdfBytes","objectsPerTick","throwOnInvalidObject","capNumbers","Infinity","_this","call","of","create","alreadyParsed","parsedObjects","shouldWaitForTick","prototype","parseDocument","context","header","parseHeader","bytes","done","parseDocumentSection","_a","sent","offset","prevOffset","position","maybeRecoverRoot","lookup","console","warn","delete","isValidCatalog","obj","catalog","trailerInfo","Root","indirectObjects","enumerateIndirectObjects","idx","len","length","ref","object","matchKeyword","major","parseRawInt","assertNext","Period","minor","forVersion","skipBinaryHeaderComment","next","parseIndirectObjectHeader","skipWhitespaceAndComments","objectNumber","generationNumber","matchIndirectObjectHeader","initialOffset","e","moveTo","parseIndirectObject","parseObject","endobj","dict","forStream","parseIntoContext","assign","tryToParseInvalidIndirectObject","startPos","msg","JSON","stringify","Error","start","failed","end","slice","parseIndirectObjects","peek","skipJibberish","maybeParseCrossRefSection","xref","createEmpty","firstInt","secondInt","byte","n","f","addEntry","addDeletedEntry","maybeParseTrailerDict","trailer","parseDict","get","Encrypt","Info","ID","maybeParseTrailer","startxref","skipWhitespace","eof","forLastCrossRefSectionOffset","isAlphaNumeric","Space","Tilde","forBytesWithOptions"],"sources":["C:\\Users\\Uzer\\Desktop\\works\\flyticket\\frontend\\flyticket\\node_modules\\pdf-lib\\src\\core\\parser\\PDFParser.ts"],"sourcesContent":["import PDFCrossRefSection from 'src/core/document/PDFCrossRefSection';\r\nimport PDFHeader from 'src/core/document/PDFHeader';\r\nimport PDFTrailer from 'src/core/document/PDFTrailer';\r\nimport {\r\n  MissingKeywordError,\r\n  MissingPDFHeaderError,\r\n  PDFInvalidObjectParsingError,\r\n  ReparseError,\r\n  StalledParserError,\r\n} from 'src/core/errors';\r\nimport PDFDict from 'src/core/objects/PDFDict';\r\nimport PDFInvalidObject from 'src/core/objects/PDFInvalidObject';\r\nimport PDFName from 'src/core/objects/PDFName';\r\nimport PDFObject from 'src/core/objects/PDFObject';\r\nimport PDFRawStream from 'src/core/objects/PDFRawStream';\r\nimport PDFRef from 'src/core/objects/PDFRef';\r\nimport ByteStream from 'src/core/parser/ByteStream';\r\nimport PDFObjectParser from 'src/core/parser/PDFObjectParser';\r\nimport PDFObjectStreamParser from 'src/core/parser/PDFObjectStreamParser';\r\nimport PDFXRefStreamParser from 'src/core/parser/PDFXRefStreamParser';\r\nimport PDFContext from 'src/core/PDFContext';\r\nimport CharCodes from 'src/core/syntax/CharCodes';\r\nimport { Keywords } from 'src/core/syntax/Keywords';\r\nimport { IsDigit } from 'src/core/syntax/Numeric';\r\nimport { waitForTick } from 'src/utils';\r\n\r\nclass PDFParser extends PDFObjectParser {\r\n  static forBytesWithOptions = (\r\n    pdfBytes: Uint8Array,\r\n    objectsPerTick?: number,\r\n    throwOnInvalidObject?: boolean,\r\n    capNumbers?: boolean,\r\n  ) =>\r\n    new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\r\n\r\n  private readonly objectsPerTick: number;\r\n  private readonly throwOnInvalidObject: boolean;\r\n  private alreadyParsed = false;\r\n  private parsedObjects = 0;\r\n\r\n  constructor(\r\n    pdfBytes: Uint8Array,\r\n    objectsPerTick = Infinity,\r\n    throwOnInvalidObject = false,\r\n    capNumbers = false,\r\n  ) {\r\n    super(ByteStream.of(pdfBytes), PDFContext.create(), capNumbers);\r\n    this.objectsPerTick = objectsPerTick;\r\n    this.throwOnInvalidObject = throwOnInvalidObject;\r\n  }\r\n\r\n  async parseDocument(): Promise<PDFContext> {\r\n    if (this.alreadyParsed) {\r\n      throw new ReparseError('PDFParser', 'parseDocument');\r\n    }\r\n    this.alreadyParsed = true;\r\n\r\n    this.context.header = this.parseHeader();\r\n\r\n    let prevOffset;\r\n    while (!this.bytes.done()) {\r\n      await this.parseDocumentSection();\r\n      const offset = this.bytes.offset();\r\n      if (offset === prevOffset) {\r\n        throw new StalledParserError(this.bytes.position());\r\n      }\r\n      prevOffset = offset;\r\n    }\r\n\r\n    this.maybeRecoverRoot();\r\n\r\n    if (this.context.lookup(PDFRef.of(0))) {\r\n      console.warn('Removing parsed object: 0 0 R');\r\n      this.context.delete(PDFRef.of(0));\r\n    }\r\n\r\n    return this.context;\r\n  }\r\n\r\n  private maybeRecoverRoot(): void {\r\n    const isValidCatalog = (obj?: PDFObject) =>\r\n      obj instanceof PDFDict &&\r\n      obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\r\n\r\n    const catalog = this.context.lookup(this.context.trailerInfo.Root);\r\n\r\n    if (!isValidCatalog(catalog)) {\r\n      const indirectObjects = this.context.enumerateIndirectObjects();\r\n      for (let idx = 0, len = indirectObjects.length; idx < len; idx++) {\r\n        const [ref, object] = indirectObjects[idx];\r\n        if (isValidCatalog(object)) {\r\n          this.context.trailerInfo.Root = ref;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private parseHeader(): PDFHeader {\r\n    while (!this.bytes.done()) {\r\n      if (this.matchKeyword(Keywords.header)) {\r\n        const major = this.parseRawInt();\r\n        this.bytes.assertNext(CharCodes.Period);\r\n        const minor = this.parseRawInt();\r\n        const header = PDFHeader.forVersion(major, minor);\r\n        this.skipBinaryHeaderComment();\r\n        return header;\r\n      }\r\n      this.bytes.next();\r\n    }\r\n\r\n    throw new MissingPDFHeaderError(this.bytes.position());\r\n  }\r\n\r\n  private parseIndirectObjectHeader(): PDFRef {\r\n    this.skipWhitespaceAndComments();\r\n    const objectNumber = this.parseRawInt();\r\n\r\n    this.skipWhitespaceAndComments();\r\n    const generationNumber = this.parseRawInt();\r\n\r\n    this.skipWhitespaceAndComments();\r\n    if (!this.matchKeyword(Keywords.obj)) {\r\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\r\n    }\r\n\r\n    return PDFRef.of(objectNumber, generationNumber);\r\n  }\r\n\r\n  private matchIndirectObjectHeader(): boolean {\r\n    const initialOffset = this.bytes.offset();\r\n    try {\r\n      this.parseIndirectObjectHeader();\r\n      return true;\r\n    } catch (e) {\r\n      this.bytes.moveTo(initialOffset);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private shouldWaitForTick = () => {\r\n    this.parsedObjects += 1;\r\n    return this.parsedObjects % this.objectsPerTick === 0;\r\n  };\r\n\r\n  private async parseIndirectObject(): Promise<PDFRef> {\r\n    const ref = this.parseIndirectObjectHeader();\r\n\r\n    this.skipWhitespaceAndComments();\r\n    const object = this.parseObject();\r\n\r\n    this.skipWhitespaceAndComments();\r\n    // if (!this.matchKeyword(Keywords.endobj)) {\r\n    // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\r\n    // }\r\n\r\n    // TODO: Log a warning if this fails...\r\n    this.matchKeyword(Keywords.endobj);\r\n\r\n    if (\r\n      object instanceof PDFRawStream &&\r\n      object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm')\r\n    ) {\r\n      await PDFObjectStreamParser.forStream(\r\n        object,\r\n        this.shouldWaitForTick,\r\n      ).parseIntoContext();\r\n    } else if (\r\n      object instanceof PDFRawStream &&\r\n      object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')\r\n    ) {\r\n      PDFXRefStreamParser.forStream(object).parseIntoContext();\r\n    } else {\r\n      this.context.assign(ref, object);\r\n    }\r\n\r\n    return ref;\r\n  }\r\n\r\n  // TODO: Improve and clean this up\r\n  private tryToParseInvalidIndirectObject() {\r\n    const startPos = this.bytes.position();\r\n\r\n    const msg = `Trying to parse invalid object: ${JSON.stringify(startPos)})`;\r\n    if (this.throwOnInvalidObject) throw new Error(msg);\r\n    console.warn(msg);\r\n\r\n    const ref = this.parseIndirectObjectHeader();\r\n\r\n    console.warn(`Invalid object ref: ${ref}`);\r\n\r\n    this.skipWhitespaceAndComments();\r\n    const start = this.bytes.offset();\r\n\r\n    let failed = true;\r\n    while (!this.bytes.done()) {\r\n      if (this.matchKeyword(Keywords.endobj)) {\r\n        failed = false;\r\n      }\r\n      if (!failed) break;\r\n      this.bytes.next();\r\n    }\r\n\r\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\r\n\r\n    const end = this.bytes.offset() - Keywords.endobj.length;\r\n\r\n    const object = PDFInvalidObject.of(this.bytes.slice(start, end));\r\n    this.context.assign(ref, object);\r\n\r\n    return ref;\r\n  }\r\n\r\n  private async parseIndirectObjects(): Promise<void> {\r\n    this.skipWhitespaceAndComments();\r\n\r\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\r\n      const initialOffset = this.bytes.offset();\r\n\r\n      try {\r\n        await this.parseIndirectObject();\r\n      } catch (e) {\r\n        // TODO: Add tracing/logging mechanism to track when this happens!\r\n        this.bytes.moveTo(initialOffset);\r\n        this.tryToParseInvalidIndirectObject();\r\n      }\r\n      this.skipWhitespaceAndComments();\r\n\r\n      // TODO: Can this be done only when needed, to avoid harming performance?\r\n      this.skipJibberish();\r\n\r\n      if (this.shouldWaitForTick()) await waitForTick();\r\n    }\r\n  }\r\n\r\n  private maybeParseCrossRefSection(): PDFCrossRefSection | void {\r\n    this.skipWhitespaceAndComments();\r\n    if (!this.matchKeyword(Keywords.xref)) return;\r\n    this.skipWhitespaceAndComments();\r\n\r\n    let objectNumber = -1;\r\n    const xref = PDFCrossRefSection.createEmpty();\r\n\r\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\r\n      const firstInt = this.parseRawInt();\r\n      this.skipWhitespaceAndComments();\r\n\r\n      const secondInt = this.parseRawInt();\r\n      this.skipWhitespaceAndComments();\r\n\r\n      const byte = this.bytes.peek();\r\n      if (byte === CharCodes.n || byte === CharCodes.f) {\r\n        const ref = PDFRef.of(objectNumber, secondInt);\r\n        if (this.bytes.next() === CharCodes.n) {\r\n          xref.addEntry(ref, firstInt);\r\n        } else {\r\n          // this.context.delete(ref);\r\n          xref.addDeletedEntry(ref, firstInt);\r\n        }\r\n        objectNumber += 1;\r\n      } else {\r\n        objectNumber = firstInt;\r\n      }\r\n      this.skipWhitespaceAndComments();\r\n    }\r\n\r\n    return xref;\r\n  }\r\n\r\n  private maybeParseTrailerDict(): void {\r\n    this.skipWhitespaceAndComments();\r\n    if (!this.matchKeyword(Keywords.trailer)) return;\r\n    this.skipWhitespaceAndComments();\r\n\r\n    const dict = this.parseDict();\r\n\r\n    const { context } = this;\r\n    context.trailerInfo = {\r\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\r\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\r\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\r\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID,\r\n    };\r\n  }\r\n\r\n  private maybeParseTrailer(): PDFTrailer | void {\r\n    this.skipWhitespaceAndComments();\r\n    if (!this.matchKeyword(Keywords.startxref)) return;\r\n    this.skipWhitespaceAndComments();\r\n\r\n    const offset = this.parseRawInt();\r\n\r\n    this.skipWhitespace();\r\n    this.matchKeyword(Keywords.eof);\r\n    this.skipWhitespaceAndComments();\r\n    this.matchKeyword(Keywords.eof);\r\n    this.skipWhitespaceAndComments();\r\n\r\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\r\n  }\r\n\r\n  private async parseDocumentSection(): Promise<void> {\r\n    await this.parseIndirectObjects();\r\n    this.maybeParseCrossRefSection();\r\n    this.maybeParseTrailerDict();\r\n    this.maybeParseTrailer();\r\n\r\n    // TODO: Can this be done only when needed, to avoid harming performance?\r\n    this.skipJibberish();\r\n  }\r\n\r\n  /**\r\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\r\n   * contain jibberish in between indirect objects. This method is designed to\r\n   * skip past that jibberish, should it exist, until it reaches the next\r\n   * indirect object header, an xref table section, or the file trailer.\r\n   */\r\n  private skipJibberish(): void {\r\n    this.skipWhitespaceAndComments();\r\n    while (!this.bytes.done()) {\r\n      const initialOffset = this.bytes.offset();\r\n      const byte = this.bytes.peek();\r\n      const isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\r\n      if (isAlphaNumeric) {\r\n        if (\r\n          this.matchKeyword(Keywords.xref) ||\r\n          this.matchKeyword(Keywords.trailer) ||\r\n          this.matchKeyword(Keywords.startxref) ||\r\n          this.matchIndirectObjectHeader()\r\n        ) {\r\n          this.bytes.moveTo(initialOffset);\r\n          break;\r\n        }\r\n      }\r\n      this.bytes.next();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Skips the binary comment following a PDF header. The specification\r\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\r\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\r\n   *\r\n   * This would imply that to strip out this binary comment, we could check for\r\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\r\n   * are 128 or greater. This works for many documents that properly comply with\r\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\r\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\r\n   * these headers correctly, we just throw out all bytes leading up to the\r\n   * first indirect object header.\r\n   */\r\n  private skipBinaryHeaderComment(): void {\r\n    this.skipWhitespaceAndComments();\r\n    try {\r\n      const initialOffset = this.bytes.offset();\r\n      this.parseIndirectObjectHeader();\r\n      this.bytes.moveTo(initialOffset);\r\n    } catch (e) {\r\n      this.bytes.next();\r\n      this.skipWhitespaceAndComments();\r\n    }\r\n  }\r\n}\r\n\r\nexport default PDFParser;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}