{"ast":null,"code":"import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds, multiline) {\n  if (multiline === void 0) {\n    multiline = false;\n  }\n  var fontSize = MIN_FONT_SIZE;\n  while (fontSize < MAX_FONT_SIZE) {\n    var linesUsed = 0;\n    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n      linesUsed += 1;\n      var line = lines[lineIdx];\n      var words = line.split(' ');\n      // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n      var spaceInLineRemaining = bounds.width;\n      for (var idx = 0, len = words.length; idx < len; idx++) {\n        var isLastWord = idx === len - 1;\n        var word = isLastWord ? words[idx] : words[idx] + ' ';\n        var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    }\n    // Return if we exceeded the allowed width\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var totalHeight = lineHeight * linesUsed;\n    // Return if we exceeded the allowed height\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n  var cellWidth = bounds.width / cellCount;\n  var cellHeight = bounds.height;\n  var fontSize = MIN_FONT_SIZE;\n  var chars = charSplit(line);\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = chars.length; idx < len; idx++) {\n      var c = chars[idx];\n      var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n    var height = font.heightAtSize(fontSize, {\n      descender: false\n    });\n    if (height > cellHeight) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n  for (var idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n  return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n  var _a;\n  var lastWhitespaceIdx = input.length;\n  while (lastWhitespaceIdx > 0) {\n    var line = input.substring(0, lastWhitespaceIdx);\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    if (width < maxWidth) {\n      var remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return {\n        line: line,\n        encoded: encoded,\n        width: width,\n        remainder: remainder\n      };\n    }\n    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n  }\n  // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined\n  };\n};\nexport var layoutMultilineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var lines = lineSplit(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n  var height = font.heightAtSize(fontSize);\n  var lineHeight = height + height * 0.2;\n  var textLines = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var y = bounds.y + bounds.height;\n  for (var idx = 0, len = lines.length; idx < len; idx++) {\n    var prevRemainder = lines[idx];\n    while (prevRemainder !== undefined) {\n      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize),\n        line = _b.line,\n        encoded = _b.encoded,\n        width = _b.width,\n        remainder = _b.remainder;\n      // prettier-ignore\n      var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n      y -= lineHeight;\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n      textLines.push({\n        text: line,\n        encoded: encoded,\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      });\n      // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n    }\n  }\n  return {\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutCombedText = function (text, _a) {\n  var fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds,\n    cellCount = _a.cellCount;\n  var line = mergeLines(cleanText(text));\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n  var cellWidth = bounds.width / cellCount;\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  var cells = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var cellOffset = 0;\n  var charOffset = 0;\n  while (cellOffset < cellCount) {\n    var _b = charAtIndex(line, charOffset),\n      char = _b[0],\n      charLength = _b[1];\n    var encoded = font.encodeText(char);\n    var width = font.widthOfTextAtSize(char, fontSize);\n    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    var x = cellCenter - width / 2;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n    cells.push({\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n  return {\n    fontSize: fontSize,\n    cells: cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutSinglelineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var line = mergeLines(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n  var encoded = font.encodeText(line);\n  var width = font.widthOfTextAtSize(line, fontSize);\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  // prettier-ignore\n  var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  return {\n    fontSize: fontSize,\n    line: {\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    },\n    bounds: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  };\n};","map":{"version":3,"names":["CombedTextLayoutError","TextAlignment","cleanText","lineSplit","mergeLines","charAtIndex","charSplit","MIN_FONT_SIZE","MAX_FONT_SIZE","computeFontSize","lines","font","bounds","multiline","fontSize","linesUsed","lineIdx","lineLen","length","line","words","split","spaceInLineRemaining","width","idx","len","isLastWord","word","widthOfWord","widthOfTextAtSize","height","heightAtSize","lineHeight","totalHeight","Math","abs","computeCombedFontSize","cellCount","cellWidth","cellHeight","chars","c","tooLong","descender","lastIndexOfWhitespace","test","undefined","splitOutLines","input","maxWidth","lastWhitespaceIdx","substring","encoded","encodeText","remainder","_a","layoutMultilineText","text","alignment","textLines","minX","x","minY","y","maxX","maxY","prevRemainder","_b","Left","Center","Right","push","trim","layoutCombedText","cells","cellOffset","charOffset","char","charLength","cellCenter","layoutSinglelineText"],"sources":["C:\\oleg\\flyticket\\frontend\\flyticket\\node_modules\\pdf-lib\\src\\api\\text\\layout.ts"],"sourcesContent":["import PDFFont from 'src/api/PDFFont';\r\nimport { CombedTextLayoutError } from 'src/api/errors';\r\nimport { TextAlignment } from 'src/api/text/alignment';\r\n\r\nimport { PDFHexString } from 'src/core';\r\nimport {\r\n  cleanText,\r\n  lineSplit,\r\n  mergeLines,\r\n  charAtIndex,\r\n  charSplit,\r\n} from 'src/utils';\r\n\r\nexport interface TextPosition {\r\n  text: string;\r\n  encoded: PDFHexString;\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface LayoutBounds {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nconst MIN_FONT_SIZE = 4;\r\nconst MAX_FONT_SIZE = 500;\r\n\r\nconst computeFontSize = (\r\n  lines: string[],\r\n  font: PDFFont,\r\n  bounds: LayoutBounds,\r\n  multiline: boolean = false,\r\n) => {\r\n  let fontSize = MIN_FONT_SIZE;\r\n\r\n  while (fontSize < MAX_FONT_SIZE) {\r\n    let linesUsed = 0;\r\n\r\n    for (\r\n      let lineIdx = 0, lineLen = lines.length;\r\n      lineIdx < lineLen;\r\n      lineIdx++\r\n    ) {\r\n      linesUsed += 1;\r\n\r\n      const line = lines[lineIdx];\r\n      const words = line.split(' ');\r\n\r\n      // Layout the words using the current `fontSize`, line wrapping\r\n      // whenever we reach the end of the current line.\r\n      let spaceInLineRemaining = bounds.width;\r\n      for (let idx = 0, len = words.length; idx < len; idx++) {\r\n        const isLastWord = idx === len - 1;\r\n        const word = isLastWord ? words[idx] : words[idx] + ' ';\r\n        const widthOfWord = font.widthOfTextAtSize(word, fontSize);\r\n        spaceInLineRemaining -= widthOfWord;\r\n        if (spaceInLineRemaining <= 0) {\r\n          linesUsed += 1;\r\n          spaceInLineRemaining = bounds.width - widthOfWord;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Return if we exceeded the allowed width\r\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\r\n\r\n    const height = font.heightAtSize(fontSize);\r\n    const lineHeight = height + height * 0.2;\r\n    const totalHeight = lineHeight * linesUsed;\r\n\r\n    // Return if we exceeded the allowed height\r\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\r\n\r\n    fontSize += 1;\r\n  }\r\n\r\n  return fontSize;\r\n};\r\n\r\nconst computeCombedFontSize = (\r\n  line: string,\r\n  font: PDFFont,\r\n  bounds: LayoutBounds,\r\n  cellCount: number,\r\n) => {\r\n  const cellWidth = bounds.width / cellCount;\r\n  const cellHeight = bounds.height;\r\n\r\n  let fontSize = MIN_FONT_SIZE;\r\n\r\n  const chars = charSplit(line);\r\n  while (fontSize < MAX_FONT_SIZE) {\r\n    for (let idx = 0, len = chars.length; idx < len; idx++) {\r\n      const c = chars[idx];\r\n      const tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\r\n      if (tooLong) return fontSize - 1;\r\n    }\r\n\r\n    const height = font.heightAtSize(fontSize, { descender: false });\r\n    if (height > cellHeight) return fontSize - 1;\r\n\r\n    fontSize += 1;\r\n  }\r\n\r\n  return fontSize;\r\n};\r\n\r\nexport interface LayoutTextOptions {\r\n  alignment: TextAlignment;\r\n  fontSize?: number;\r\n  font: PDFFont;\r\n  bounds: LayoutBounds;\r\n}\r\n\r\nexport interface MultilineTextLayout {\r\n  bounds: LayoutBounds;\r\n  lines: TextPosition[];\r\n  fontSize: number;\r\n  lineHeight: number;\r\n}\r\n\r\nconst lastIndexOfWhitespace = (line: string) => {\r\n  for (let idx = line.length; idx > 0; idx--) {\r\n    if (/\\s/.test(line[idx])) return idx;\r\n  }\r\n  return undefined;\r\n};\r\n\r\nconst splitOutLines = (\r\n  input: string,\r\n  maxWidth: number,\r\n  font: PDFFont,\r\n  fontSize: number,\r\n) => {\r\n  let lastWhitespaceIdx = input.length;\r\n  while (lastWhitespaceIdx > 0) {\r\n    const line = input.substring(0, lastWhitespaceIdx);\r\n    const encoded = font.encodeText(line);\r\n    const width = font.widthOfTextAtSize(line, fontSize);\r\n    if (width < maxWidth) {\r\n      const remainder = input.substring(lastWhitespaceIdx) || undefined;\r\n      return { line, encoded, width, remainder };\r\n    }\r\n    lastWhitespaceIdx = lastIndexOfWhitespace(line) ?? 0;\r\n  }\r\n\r\n  // We were unable to split the input enough to get a chunk that would fit\r\n  // within the specified `maxWidth` so we'll just return everything\r\n  return {\r\n    line: input,\r\n    encoded: font.encodeText(input),\r\n    width: font.widthOfTextAtSize(input, fontSize),\r\n    remainder: undefined,\r\n  };\r\n};\r\n\r\nexport const layoutMultilineText = (\r\n  text: string,\r\n  { alignment, fontSize, font, bounds }: LayoutTextOptions,\r\n): MultilineTextLayout => {\r\n  const lines = lineSplit(cleanText(text));\r\n\r\n  if (fontSize === undefined || fontSize === 0) {\r\n    fontSize = computeFontSize(lines, font, bounds, true);\r\n  }\r\n  const height = font.heightAtSize(fontSize);\r\n  const lineHeight = height + height * 0.2;\r\n\r\n  const textLines: TextPosition[] = [];\r\n\r\n  let minX = bounds.x;\r\n  let minY = bounds.y;\r\n  let maxX = bounds.x + bounds.width;\r\n  let maxY = bounds.y + bounds.height;\r\n\r\n  let y = bounds.y + bounds.height;\r\n  for (let idx = 0, len = lines.length; idx < len; idx++) {\r\n    let prevRemainder: string | undefined = lines[idx];\r\n    while (prevRemainder !== undefined) {\r\n      const { line, encoded, width, remainder } = splitOutLines(\r\n        prevRemainder,\r\n        bounds.width,\r\n        font,\r\n        fontSize,\r\n      );\r\n\r\n      // prettier-ignore\r\n      const x = (\r\n          alignment === TextAlignment.Left   ? bounds.x\r\n        : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\r\n        : alignment === TextAlignment.Right  ? bounds.x + bounds.width - width\r\n        : bounds.x\r\n      );\r\n\r\n      y -= lineHeight;\r\n\r\n      if (x < minX) minX = x;\r\n      if (y < minY) minY = y;\r\n      if (x + width > maxX) maxX = x + width;\r\n      if (y + height > maxY) maxY = y + height;\r\n\r\n      textLines.push({ text: line, encoded, width, height, x, y });\r\n\r\n      // Only trim lines that we had to split ourselves. So we won't trim lines\r\n      // that the user provided themselves with whitespace.\r\n      prevRemainder = remainder?.trim();\r\n    }\r\n  }\r\n\r\n  return {\r\n    fontSize,\r\n    lineHeight,\r\n    lines: textLines,\r\n    bounds: {\r\n      x: minX,\r\n      y: minY,\r\n      width: maxX - minX,\r\n      height: maxY - minY,\r\n    },\r\n  };\r\n};\r\n\r\nexport interface LayoutCombedTextOptions {\r\n  fontSize?: number;\r\n  font: PDFFont;\r\n  bounds: LayoutBounds;\r\n  cellCount: number;\r\n}\r\n\r\nexport interface CombedTextLayout {\r\n  bounds: LayoutBounds;\r\n  cells: TextPosition[];\r\n  fontSize: number;\r\n}\r\n\r\nexport const layoutCombedText = (\r\n  text: string,\r\n  { fontSize, font, bounds, cellCount }: LayoutCombedTextOptions,\r\n): CombedTextLayout => {\r\n  const line = mergeLines(cleanText(text));\r\n\r\n  if (line.length > cellCount) {\r\n    throw new CombedTextLayoutError(line.length, cellCount);\r\n  }\r\n\r\n  if (fontSize === undefined || fontSize === 0) {\r\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\r\n  }\r\n\r\n  const cellWidth = bounds.width / cellCount;\r\n\r\n  const height = font.heightAtSize(fontSize, { descender: false });\r\n  const y = bounds.y + (bounds.height / 2 - height / 2);\r\n\r\n  const cells: TextPosition[] = [];\r\n\r\n  let minX = bounds.x;\r\n  let minY = bounds.y;\r\n  let maxX = bounds.x + bounds.width;\r\n  let maxY = bounds.y + bounds.height;\r\n\r\n  let cellOffset = 0;\r\n  let charOffset = 0;\r\n  while (cellOffset < cellCount) {\r\n    const [char, charLength] = charAtIndex(line, charOffset);\r\n\r\n    const encoded = font.encodeText(char);\r\n    const width = font.widthOfTextAtSize(char, fontSize);\r\n\r\n    const cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\r\n    const x = cellCenter - width / 2;\r\n\r\n    if (x < minX) minX = x;\r\n    if (y < minY) minY = y;\r\n    if (x + width > maxX) maxX = x + width;\r\n    if (y + height > maxY) maxY = y + height;\r\n\r\n    cells.push({ text: line, encoded, width, height, x, y });\r\n\r\n    cellOffset += 1;\r\n    charOffset += charLength;\r\n  }\r\n\r\n  return {\r\n    fontSize,\r\n    cells,\r\n    bounds: {\r\n      x: minX,\r\n      y: minY,\r\n      width: maxX - minX,\r\n      height: maxY - minY,\r\n    },\r\n  };\r\n};\r\n\r\nexport interface LayoutSinglelineTextOptions {\r\n  alignment: TextAlignment;\r\n  fontSize?: number;\r\n  font: PDFFont;\r\n  bounds: LayoutBounds;\r\n}\r\n\r\nexport interface SinglelineTextLayout {\r\n  bounds: LayoutBounds;\r\n  line: TextPosition;\r\n  fontSize: number;\r\n}\r\n\r\nexport const layoutSinglelineText = (\r\n  text: string,\r\n  { alignment, fontSize, font, bounds }: LayoutSinglelineTextOptions,\r\n): SinglelineTextLayout => {\r\n  const line = mergeLines(cleanText(text));\r\n\r\n  if (fontSize === undefined || fontSize === 0) {\r\n    fontSize = computeFontSize([line], font, bounds);\r\n  }\r\n\r\n  const encoded = font.encodeText(line);\r\n  const width = font.widthOfTextAtSize(line, fontSize);\r\n  const height = font.heightAtSize(fontSize, { descender: false });\r\n\r\n  // prettier-ignore\r\n  const x = (\r\n      alignment === TextAlignment.Left   ? bounds.x\r\n    : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\r\n    : alignment === TextAlignment.Right  ? bounds.x + bounds.width - width\r\n    : bounds.x\r\n  );\r\n\r\n  const y = bounds.y + (bounds.height / 2 - height / 2);\r\n\r\n  return {\r\n    fontSize,\r\n    line: { text: line, encoded, width, height, x, y },\r\n    bounds: { x, y, width, height },\r\n  };\r\n};\r\n"],"mappings":"AACA,SAASA,qBAAqB,QAAE;AAChC,SAASC,aAAa,QAAE;AAGxB,SACEC,SAAS,EACTC,SAAS,EACTC,UAAU,EACVC,WAAW,EACXC,SAAS,QACV;AAkBD,IAAMC,aAAa,GAAG,CAAC;AACvB,IAAMC,aAAa,GAAG,GAAG;AAEzB,IAAMC,eAAe,GAAG,SAAAA,CACtBC,KAAe,EACfC,IAAa,EACbC,MAAoB,EACpBC,SAA0B;EAA1B,IAAAA,SAAA;IAAAA,SAAA,QAA0B;EAAA;EAE1B,IAAIC,QAAQ,GAAGP,aAAa;EAE5B,OAAOO,QAAQ,GAAGN,aAAa,EAAE;IAC/B,IAAIO,SAAS,GAAG,CAAC;IAEjB,KACE,IAAIC,OAAO,GAAG,CAAC,EAAEC,OAAO,GAAGP,KAAK,CAACQ,MAAM,EACvCF,OAAO,GAAGC,OAAO,EACjBD,OAAO,EAAE,EACT;MACAD,SAAS,IAAI,CAAC;MAEd,IAAMI,IAAI,GAAGT,KAAK,CAACM,OAAO,CAAC;MAC3B,IAAMI,KAAK,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;MAE7B;MACA;MACA,IAAIC,oBAAoB,GAAGV,MAAM,CAACW,KAAK;MACvC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAGL,KAAK,CAACF,MAAM,EAAEM,GAAG,GAAGC,GAAG,EAAED,GAAG,EAAE,EAAE;QACtD,IAAME,UAAU,GAAGF,GAAG,KAAKC,GAAG,GAAG,CAAC;QAClC,IAAME,IAAI,GAAGD,UAAU,GAAGN,KAAK,CAACI,GAAG,CAAC,GAAGJ,KAAK,CAACI,GAAG,CAAC,GAAG,GAAG;QACvD,IAAMI,WAAW,GAAGjB,IAAI,CAACkB,iBAAiB,CAACF,IAAI,EAAEb,QAAQ,CAAC;QAC1DQ,oBAAoB,IAAIM,WAAW;QACnC,IAAIN,oBAAoB,IAAI,CAAC,EAAE;UAC7BP,SAAS,IAAI,CAAC;UACdO,oBAAoB,GAAGV,MAAM,CAACW,KAAK,GAAGK,WAAW;;;;IAKvD;IACA,IAAI,CAACf,SAAS,IAAIE,SAAS,GAAGL,KAAK,CAACQ,MAAM,EAAE,OAAOJ,QAAQ,GAAG,CAAC;IAE/D,IAAMgB,MAAM,GAAGnB,IAAI,CAACoB,YAAY,CAACjB,QAAQ,CAAC;IAC1C,IAAMkB,UAAU,GAAGF,MAAM,GAAGA,MAAM,GAAG,GAAG;IACxC,IAAMG,WAAW,GAAGD,UAAU,GAAGjB,SAAS;IAE1C;IACA,IAAIkB,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACvB,MAAM,CAACkB,MAAM,CAAC,EAAE,OAAOhB,QAAQ,GAAG,CAAC;IAE9DA,QAAQ,IAAI,CAAC;;EAGf,OAAOA,QAAQ;AACjB,CAAC;AAED,IAAMsB,qBAAqB,GAAG,SAAAA,CAC5BjB,IAAY,EACZR,IAAa,EACbC,MAAoB,EACpByB,SAAiB;EAEjB,IAAMC,SAAS,GAAG1B,MAAM,CAACW,KAAK,GAAGc,SAAS;EAC1C,IAAME,UAAU,GAAG3B,MAAM,CAACkB,MAAM;EAEhC,IAAIhB,QAAQ,GAAGP,aAAa;EAE5B,IAAMiC,KAAK,GAAGlC,SAAS,CAACa,IAAI,CAAC;EAC7B,OAAOL,QAAQ,GAAGN,aAAa,EAAE;IAC/B,KAAK,IAAIgB,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAGe,KAAK,CAACtB,MAAM,EAAEM,GAAG,GAAGC,GAAG,EAAED,GAAG,EAAE,EAAE;MACtD,IAAMiB,CAAC,GAAGD,KAAK,CAAChB,GAAG,CAAC;MACpB,IAAMkB,OAAO,GAAG/B,IAAI,CAACkB,iBAAiB,CAACY,CAAC,EAAE3B,QAAQ,CAAC,GAAGwB,SAAS,GAAG,IAAI;MACtE,IAAII,OAAO,EAAE,OAAO5B,QAAQ,GAAG,CAAC;;IAGlC,IAAMgB,MAAM,GAAGnB,IAAI,CAACoB,YAAY,CAACjB,QAAQ,EAAE;MAAE6B,SAAS,EAAE;IAAK,CAAE,CAAC;IAChE,IAAIb,MAAM,GAAGS,UAAU,EAAE,OAAOzB,QAAQ,GAAG,CAAC;IAE5CA,QAAQ,IAAI,CAAC;;EAGf,OAAOA,QAAQ;AACjB,CAAC;AAgBD,IAAM8B,qBAAqB,GAAG,SAAAA,CAACzB,IAAY;EACzC,KAAK,IAAIK,GAAG,GAAGL,IAAI,CAACD,MAAM,EAAEM,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;IAC1C,IAAI,IAAI,CAACqB,IAAI,CAAC1B,IAAI,CAACK,GAAG,CAAC,CAAC,EAAE,OAAOA,GAAG;;EAEtC,OAAOsB,SAAS;AAClB,CAAC;AAED,IAAMC,aAAa,GAAG,SAAAA,CACpBC,KAAa,EACbC,QAAgB,EAChBtC,IAAa,EACbG,QAAgB;;EAEhB,IAAIoC,iBAAiB,GAAGF,KAAK,CAAC9B,MAAM;EACpC,OAAOgC,iBAAiB,GAAG,CAAC,EAAE;IAC5B,IAAM/B,IAAI,GAAG6B,KAAK,CAACG,SAAS,CAAC,CAAC,EAAED,iBAAiB,CAAC;IAClD,IAAME,OAAO,GAAGzC,IAAI,CAAC0C,UAAU,CAAClC,IAAI,CAAC;IACrC,IAAMI,KAAK,GAAGZ,IAAI,CAACkB,iBAAiB,CAACV,IAAI,EAAEL,QAAQ,CAAC;IACpD,IAAIS,KAAK,GAAG0B,QAAQ,EAAE;MACpB,IAAMK,SAAS,GAAGN,KAAK,CAACG,SAAS,CAACD,iBAAiB,CAAC,IAAIJ,SAAS;MACjE,OAAO;QAAE3B,IAAI,EAAAA,IAAA;QAAEiC,OAAO,EAAAA,OAAA;QAAE7B,KAAK,EAAAA,KAAA;QAAE+B,SAAS,EAAAA;MAAA,CAAE;;IAE5CJ,iBAAiB,IAAAK,EAAA,GAAGX,qBAAqB,CAACzB,IAAI,CAAC,cAAAoC,EAAA,cAAAA,EAAA,GAAI,CAAC;;EAGtD;EACA;EACA,OAAO;IACLpC,IAAI,EAAE6B,KAAK;IACXI,OAAO,EAAEzC,IAAI,CAAC0C,UAAU,CAACL,KAAK,CAAC;IAC/BzB,KAAK,EAAEZ,IAAI,CAACkB,iBAAiB,CAACmB,KAAK,EAAElC,QAAQ,CAAC;IAC9CwC,SAAS,EAAER;GACZ;AACH,CAAC;AAED,OAAO,IAAMU,mBAAmB,GAAG,SAAAA,CACjCC,IAAY,EACZF,EAAwD;MAAtDG,SAAS,GAAAH,EAAA,CAAAG,SAAA;IAAE5C,QAAQ,GAAAyC,EAAA,CAAAzC,QAAA;IAAEH,IAAI,GAAA4C,EAAA,CAAA5C,IAAA;IAAEC,MAAM,GAAA2C,EAAA,CAAA3C,MAAA;EAEnC,IAAMF,KAAK,GAAGP,SAAS,CAACD,SAAS,CAACuD,IAAI,CAAC,CAAC;EAExC,IAAI3C,QAAQ,KAAKgC,SAAS,IAAIhC,QAAQ,KAAK,CAAC,EAAE;IAC5CA,QAAQ,GAAGL,eAAe,CAACC,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAE,IAAI,CAAC;;EAEvD,IAAMkB,MAAM,GAAGnB,IAAI,CAACoB,YAAY,CAACjB,QAAQ,CAAC;EAC1C,IAAMkB,UAAU,GAAGF,MAAM,GAAGA,MAAM,GAAG,GAAG;EAExC,IAAM6B,SAAS,GAAmB,EAAE;EAEpC,IAAIC,IAAI,GAAGhD,MAAM,CAACiD,CAAC;EACnB,IAAIC,IAAI,GAAGlD,MAAM,CAACmD,CAAC;EACnB,IAAIC,IAAI,GAAGpD,MAAM,CAACiD,CAAC,GAAGjD,MAAM,CAACW,KAAK;EAClC,IAAI0C,IAAI,GAAGrD,MAAM,CAACmD,CAAC,GAAGnD,MAAM,CAACkB,MAAM;EAEnC,IAAIiC,CAAC,GAAGnD,MAAM,CAACmD,CAAC,GAAGnD,MAAM,CAACkB,MAAM;EAChC,KAAK,IAAIN,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAGf,KAAK,CAACQ,MAAM,EAAEM,GAAG,GAAGC,GAAG,EAAED,GAAG,EAAE,EAAE;IACtD,IAAI0C,aAAa,GAAuBxD,KAAK,CAACc,GAAG,CAAC;IAClD,OAAO0C,aAAa,KAAKpB,SAAS,EAAE;MAC5B,IAAAqB,EAAA,GAAsCpB,aAAa,CACvDmB,aAAa,EACbtD,MAAM,CAACW,KAAK,EACZZ,IAAI,EACJG,QAAQ,CACT;QALOK,IAAI,GAAAgD,EAAA,CAAAhD,IAAA;QAAEiC,OAAO,GAAAe,EAAA,CAAAf,OAAA;QAAE7B,KAAK,GAAA4C,EAAA,CAAA5C,KAAA;QAAE+B,SAAS,GAAAa,EAAA,CAAAb,SAKtC;MAED;MACA,IAAMO,CAAC,GACHH,SAAS,KAAKzD,aAAa,CAACmE,IAAI,GAAKxD,MAAM,CAACiD,CAAC,GAC7CH,SAAS,KAAKzD,aAAa,CAACoE,MAAM,GAAGzD,MAAM,CAACiD,CAAC,GAAIjD,MAAM,CAACW,KAAK,GAAG,CAAE,GAAIA,KAAK,GAAG,CAAE,GAChFmC,SAAS,KAAKzD,aAAa,CAACqE,KAAK,GAAI1D,MAAM,CAACiD,CAAC,GAAGjD,MAAM,CAACW,KAAK,GAAGA,KAAK,GACpEX,MAAM,CAACiD,CACV;MAEDE,CAAC,IAAI/B,UAAU;MAEf,IAAI6B,CAAC,GAAGD,IAAI,EAAEA,IAAI,GAAGC,CAAC;MACtB,IAAIE,CAAC,GAAGD,IAAI,EAAEA,IAAI,GAAGC,CAAC;MACtB,IAAIF,CAAC,GAAGtC,KAAK,GAAGyC,IAAI,EAAEA,IAAI,GAAGH,CAAC,GAAGtC,KAAK;MACtC,IAAIwC,CAAC,GAAGjC,MAAM,GAAGmC,IAAI,EAAEA,IAAI,GAAGF,CAAC,GAAGjC,MAAM;MAExC6B,SAAS,CAACY,IAAI,CAAC;QAAEd,IAAI,EAAEtC,IAAI;QAAEiC,OAAO,EAAAA,OAAA;QAAE7B,KAAK,EAAAA,KAAA;QAAEO,MAAM,EAAAA,MAAA;QAAE+B,CAAC,EAAAA,CAAA;QAAEE,CAAC,EAAAA;MAAA,CAAE,CAAC;MAE5D;MACA;MACAG,aAAa,GAAGZ,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEkB,IAAI,EAAE;;;EAIrC,OAAO;IACL1D,QAAQ,EAAAA,QAAA;IACRkB,UAAU,EAAAA,UAAA;IACVtB,KAAK,EAAEiD,SAAS;IAChB/C,MAAM,EAAE;MACNiD,CAAC,EAAED,IAAI;MACPG,CAAC,EAAED,IAAI;MACPvC,KAAK,EAAEyC,IAAI,GAAGJ,IAAI;MAClB9B,MAAM,EAAEmC,IAAI,GAAGH;;GAElB;AACH,CAAC;AAeD,OAAO,IAAMW,gBAAgB,GAAG,SAAAA,CAC9BhB,IAAY,EACZF,EAA8D;MAA5DzC,QAAQ,GAAAyC,EAAA,CAAAzC,QAAA;IAAEH,IAAI,GAAA4C,EAAA,CAAA5C,IAAA;IAAEC,MAAM,GAAA2C,EAAA,CAAA3C,MAAA;IAAEyB,SAAS,GAAAkB,EAAA,CAAAlB,SAAA;EAEnC,IAAMlB,IAAI,GAAGf,UAAU,CAACF,SAAS,CAACuD,IAAI,CAAC,CAAC;EAExC,IAAItC,IAAI,CAACD,MAAM,GAAGmB,SAAS,EAAE;IAC3B,MAAM,IAAIrC,qBAAqB,CAACmB,IAAI,CAACD,MAAM,EAAEmB,SAAS,CAAC;;EAGzD,IAAIvB,QAAQ,KAAKgC,SAAS,IAAIhC,QAAQ,KAAK,CAAC,EAAE;IAC5CA,QAAQ,GAAGsB,qBAAqB,CAACjB,IAAI,EAAER,IAAI,EAAEC,MAAM,EAAEyB,SAAS,CAAC;;EAGjE,IAAMC,SAAS,GAAG1B,MAAM,CAACW,KAAK,GAAGc,SAAS;EAE1C,IAAMP,MAAM,GAAGnB,IAAI,CAACoB,YAAY,CAACjB,QAAQ,EAAE;IAAE6B,SAAS,EAAE;EAAK,CAAE,CAAC;EAChE,IAAMoB,CAAC,GAAGnD,MAAM,CAACmD,CAAC,IAAInD,MAAM,CAACkB,MAAM,GAAG,CAAC,GAAGA,MAAM,GAAG,CAAC,CAAC;EAErD,IAAM4C,KAAK,GAAmB,EAAE;EAEhC,IAAId,IAAI,GAAGhD,MAAM,CAACiD,CAAC;EACnB,IAAIC,IAAI,GAAGlD,MAAM,CAACmD,CAAC;EACnB,IAAIC,IAAI,GAAGpD,MAAM,CAACiD,CAAC,GAAGjD,MAAM,CAACW,KAAK;EAClC,IAAI0C,IAAI,GAAGrD,MAAM,CAACmD,CAAC,GAAGnD,MAAM,CAACkB,MAAM;EAEnC,IAAI6C,UAAU,GAAG,CAAC;EAClB,IAAIC,UAAU,GAAG,CAAC;EAClB,OAAOD,UAAU,GAAGtC,SAAS,EAAE;IACvB,IAAA8B,EAAA,GAAqB9D,WAAW,CAACc,IAAI,EAAEyD,UAAU,CAAC;MAAjDC,IAAI,GAAAV,EAAA;MAAEW,UAAU,GAAAX,EAAA,GAAiC;IAExD,IAAMf,OAAO,GAAGzC,IAAI,CAAC0C,UAAU,CAACwB,IAAI,CAAC;IACrC,IAAMtD,KAAK,GAAGZ,IAAI,CAACkB,iBAAiB,CAACgD,IAAI,EAAE/D,QAAQ,CAAC;IAEpD,IAAMiE,UAAU,GAAGnE,MAAM,CAACiD,CAAC,IAAIvB,SAAS,GAAGqC,UAAU,GAAGrC,SAAS,GAAG,CAAC,CAAC;IACtE,IAAMuB,CAAC,GAAGkB,UAAU,GAAGxD,KAAK,GAAG,CAAC;IAEhC,IAAIsC,CAAC,GAAGD,IAAI,EAAEA,IAAI,GAAGC,CAAC;IACtB,IAAIE,CAAC,GAAGD,IAAI,EAAEA,IAAI,GAAGC,CAAC;IACtB,IAAIF,CAAC,GAAGtC,KAAK,GAAGyC,IAAI,EAAEA,IAAI,GAAGH,CAAC,GAAGtC,KAAK;IACtC,IAAIwC,CAAC,GAAGjC,MAAM,GAAGmC,IAAI,EAAEA,IAAI,GAAGF,CAAC,GAAGjC,MAAM;IAExC4C,KAAK,CAACH,IAAI,CAAC;MAAEd,IAAI,EAAEtC,IAAI;MAAEiC,OAAO,EAAAA,OAAA;MAAE7B,KAAK,EAAAA,KAAA;MAAEO,MAAM,EAAAA,MAAA;MAAE+B,CAAC,EAAAA,CAAA;MAAEE,CAAC,EAAAA;IAAA,CAAE,CAAC;IAExDY,UAAU,IAAI,CAAC;IACfC,UAAU,IAAIE,UAAU;;EAG1B,OAAO;IACLhE,QAAQ,EAAAA,QAAA;IACR4D,KAAK,EAAAA,KAAA;IACL9D,MAAM,EAAE;MACNiD,CAAC,EAAED,IAAI;MACPG,CAAC,EAAED,IAAI;MACPvC,KAAK,EAAEyC,IAAI,GAAGJ,IAAI;MAClB9B,MAAM,EAAEmC,IAAI,GAAGH;;GAElB;AACH,CAAC;AAeD,OAAO,IAAMkB,oBAAoB,GAAG,SAAAA,CAClCvB,IAAY,EACZF,EAAkE;MAAhEG,SAAS,GAAAH,EAAA,CAAAG,SAAA;IAAE5C,QAAQ,GAAAyC,EAAA,CAAAzC,QAAA;IAAEH,IAAI,GAAA4C,EAAA,CAAA5C,IAAA;IAAEC,MAAM,GAAA2C,EAAA,CAAA3C,MAAA;EAEnC,IAAMO,IAAI,GAAGf,UAAU,CAACF,SAAS,CAACuD,IAAI,CAAC,CAAC;EAExC,IAAI3C,QAAQ,KAAKgC,SAAS,IAAIhC,QAAQ,KAAK,CAAC,EAAE;IAC5CA,QAAQ,GAAGL,eAAe,CAAC,CAACU,IAAI,CAAC,EAAER,IAAI,EAAEC,MAAM,CAAC;;EAGlD,IAAMwC,OAAO,GAAGzC,IAAI,CAAC0C,UAAU,CAAClC,IAAI,CAAC;EACrC,IAAMI,KAAK,GAAGZ,IAAI,CAACkB,iBAAiB,CAACV,IAAI,EAAEL,QAAQ,CAAC;EACpD,IAAMgB,MAAM,GAAGnB,IAAI,CAACoB,YAAY,CAACjB,QAAQ,EAAE;IAAE6B,SAAS,EAAE;EAAK,CAAE,CAAC;EAEhE;EACA,IAAMkB,CAAC,GACHH,SAAS,KAAKzD,aAAa,CAACmE,IAAI,GAAKxD,MAAM,CAACiD,CAAC,GAC7CH,SAAS,KAAKzD,aAAa,CAACoE,MAAM,GAAGzD,MAAM,CAACiD,CAAC,GAAIjD,MAAM,CAACW,KAAK,GAAG,CAAE,GAAIA,KAAK,GAAG,CAAE,GAChFmC,SAAS,KAAKzD,aAAa,CAACqE,KAAK,GAAI1D,MAAM,CAACiD,CAAC,GAAGjD,MAAM,CAACW,KAAK,GAAGA,KAAK,GACpEX,MAAM,CAACiD,CACV;EAED,IAAME,CAAC,GAAGnD,MAAM,CAACmD,CAAC,IAAInD,MAAM,CAACkB,MAAM,GAAG,CAAC,GAAGA,MAAM,GAAG,CAAC,CAAC;EAErD,OAAO;IACLhB,QAAQ,EAAAA,QAAA;IACRK,IAAI,EAAE;MAAEsC,IAAI,EAAEtC,IAAI;MAAEiC,OAAO,EAAAA,OAAA;MAAE7B,KAAK,EAAAA,KAAA;MAAEO,MAAM,EAAAA,MAAA;MAAE+B,CAAC,EAAAA,CAAA;MAAEE,CAAC,EAAAA;IAAA,CAAE;IAClDnD,MAAM,EAAE;MAAEiD,CAAC,EAAAA,CAAA;MAAEE,CAAC,EAAAA,CAAA;MAAExC,KAAK,EAAAA,KAAA;MAAEO,MAAM,EAAAA;IAAA;GAC9B;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}