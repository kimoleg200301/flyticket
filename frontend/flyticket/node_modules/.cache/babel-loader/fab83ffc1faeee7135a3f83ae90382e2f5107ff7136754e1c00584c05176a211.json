{"ast":null,"code":"import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\r\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\r\n * The primary use case for this is to copy pages between PDFs.\r\n *\r\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\r\n * object with its [[PDFObject.clone]] method:\r\n *\r\n * ```\r\n *   const src: PDFContext = ...\r\n *   const dest: PDFContext = ...\r\n *   const originalObject: PDFObject = ...\r\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\r\n *   const clonedObject = originalObject.clone();\r\n * ```\r\n *\r\n * Copying an object is equivalent to cloning it and then copying over any other\r\n * objects that it references. Note that only dictionaries, arrays, and streams\r\n * (or structures build from them) can contain indirect references to other\r\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\r\n * supported, but is equivalent to cloning it.\r\n */\nvar PDFObjectCopier = /** @class */function () {\n  function PDFObjectCopier(src, dest) {\n    var _this = this;\n    this.traversedObjects = new Map();\n    // prettier-ignore\n    this.copy = function (object) {\n      return object instanceof PDFPageLeaf ? _this.copyPDFPage(object) : object instanceof PDFDict ? _this.copyPDFDict(object) : object instanceof PDFArray ? _this.copyPDFArray(object) : object instanceof PDFStream ? _this.copyPDFStream(object) : object instanceof PDFRef ? _this.copyPDFIndirectObject(object) : object.clone();\n    };\n    this.copyPDFPage = function (originalPage) {\n      var clonedPage = originalPage.clone();\n      // Move any entries that the originalPage is inheriting from its parent\n      // tree nodes directly into originalPage so they are preserved during\n      // the copy.\n      var InheritableEntries = PDFPageLeaf.InheritableEntries;\n      for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n        var key = PDFName.of(InheritableEntries[idx]);\n        var value = clonedPage.getInheritableAttribute(key);\n        if (!clonedPage.get(key) && value) clonedPage.set(key, value);\n      }\n      // Remove the parent reference to prevent the whole donor document's page\n      // tree from being copied when we only need a single page.\n      clonedPage.delete(PDFName.of('Parent'));\n      return _this.copyPDFDict(clonedPage);\n    };\n    this.copyPDFDict = function (originalDict) {\n      if (_this.traversedObjects.has(originalDict)) {\n        return _this.traversedObjects.get(originalDict);\n      }\n      var clonedDict = originalDict.clone(_this.dest);\n      _this.traversedObjects.set(originalDict, clonedDict);\n      var entries = originalDict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedDict.set(key, _this.copy(value));\n      }\n      return clonedDict;\n    };\n    this.copyPDFArray = function (originalArray) {\n      if (_this.traversedObjects.has(originalArray)) {\n        return _this.traversedObjects.get(originalArray);\n      }\n      var clonedArray = originalArray.clone(_this.dest);\n      _this.traversedObjects.set(originalArray, clonedArray);\n      for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n        var value = originalArray.get(idx);\n        clonedArray.set(idx, _this.copy(value));\n      }\n      return clonedArray;\n    };\n    this.copyPDFStream = function (originalStream) {\n      if (_this.traversedObjects.has(originalStream)) {\n        return _this.traversedObjects.get(originalStream);\n      }\n      var clonedStream = originalStream.clone(_this.dest);\n      _this.traversedObjects.set(originalStream, clonedStream);\n      var entries = originalStream.dict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedStream.dict.set(key, _this.copy(value));\n      }\n      return clonedStream;\n    };\n    this.copyPDFIndirectObject = function (ref) {\n      var alreadyMapped = _this.traversedObjects.has(ref);\n      if (!alreadyMapped) {\n        var newRef = _this.dest.nextRef();\n        _this.traversedObjects.set(ref, newRef);\n        var dereferencedValue = _this.src.lookup(ref);\n        if (dereferencedValue) {\n          var cloned = _this.copy(dereferencedValue);\n          _this.dest.assign(newRef, cloned);\n        }\n      }\n      return _this.traversedObjects.get(ref);\n    };\n    this.src = src;\n    this.dest = dest;\n  }\n  PDFObjectCopier.for = function (src, dest) {\n    return new PDFObjectCopier(src, dest);\n  };\n  return PDFObjectCopier;\n}();\nexport default PDFObjectCopier;","map":{"version":3,"names":["PDFArray","PDFDict","PDFName","PDFRef","PDFStream","PDFPageLeaf","PDFObjectCopier","src","dest","_this","traversedObjects","Map","copy","object","copyPDFPage","copyPDFDict","copyPDFArray","copyPDFStream","copyPDFIndirectObject","clone","originalPage","clonedPage","InheritableEntries","idx","len","length","key","of","value","getInheritableAttribute","get","set","delete","originalDict","has","clonedDict","entries","_a","originalArray","clonedArray","size","originalStream","clonedStream","dict","ref","alreadyMapped","newRef","nextRef","dereferencedValue","lookup","cloned","assign","for"],"sources":["C:\\oleg\\flyticket\\frontend\\flyticket\\node_modules\\pdf-lib\\src\\core\\PDFObjectCopier.ts"],"sourcesContent":["import PDFArray from 'src/core/objects/PDFArray';\r\nimport PDFDict from 'src/core/objects/PDFDict';\r\nimport PDFName from 'src/core/objects/PDFName';\r\nimport PDFObject from 'src/core/objects/PDFObject';\r\nimport PDFRef from 'src/core/objects/PDFRef';\r\nimport PDFStream from 'src/core/objects/PDFStream';\r\nimport PDFContext from 'src/core/PDFContext';\r\nimport PDFPageLeaf from 'src/core/structures/PDFPageLeaf';\r\n\r\n/**\r\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\r\n * The primary use case for this is to copy pages between PDFs.\r\n *\r\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\r\n * object with its [[PDFObject.clone]] method:\r\n *\r\n * ```\r\n *   const src: PDFContext = ...\r\n *   const dest: PDFContext = ...\r\n *   const originalObject: PDFObject = ...\r\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\r\n *   const clonedObject = originalObject.clone();\r\n * ```\r\n *\r\n * Copying an object is equivalent to cloning it and then copying over any other\r\n * objects that it references. Note that only dictionaries, arrays, and streams\r\n * (or structures build from them) can contain indirect references to other\r\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\r\n * supported, but is equivalent to cloning it.\r\n */\r\nclass PDFObjectCopier {\r\n  static for = (src: PDFContext, dest: PDFContext) =>\r\n    new PDFObjectCopier(src, dest);\r\n\r\n  private readonly src: PDFContext;\r\n  private readonly dest: PDFContext;\r\n  private readonly traversedObjects = new Map<PDFObject, PDFObject>();\r\n\r\n  private constructor(src: PDFContext, dest: PDFContext) {\r\n    this.src = src;\r\n    this.dest = dest;\r\n  }\r\n\r\n  // prettier-ignore\r\n  copy = <T extends PDFObject>(object: T): T => (\r\n      object instanceof PDFPageLeaf ? this.copyPDFPage(object)\r\n    : object instanceof PDFDict     ? this.copyPDFDict(object)\r\n    : object instanceof PDFArray    ? this.copyPDFArray(object)\r\n    : object instanceof PDFStream   ? this.copyPDFStream(object)\r\n    : object instanceof PDFRef      ? this.copyPDFIndirectObject(object)\r\n    : object.clone()\r\n  ) as T;\r\n\r\n  private copyPDFPage = (originalPage: PDFPageLeaf): PDFPageLeaf => {\r\n    const clonedPage = originalPage.clone();\r\n\r\n    // Move any entries that the originalPage is inheriting from its parent\r\n    // tree nodes directly into originalPage so they are preserved during\r\n    // the copy.\r\n    const { InheritableEntries } = PDFPageLeaf;\r\n    for (let idx = 0, len = InheritableEntries.length; idx < len; idx++) {\r\n      const key = PDFName.of(InheritableEntries[idx]);\r\n      const value = clonedPage.getInheritableAttribute(key)!;\r\n      if (!clonedPage.get(key) && value) clonedPage.set(key, value);\r\n    }\r\n\r\n    // Remove the parent reference to prevent the whole donor document's page\r\n    // tree from being copied when we only need a single page.\r\n    clonedPage.delete(PDFName.of('Parent'));\r\n\r\n    return this.copyPDFDict(clonedPage) as PDFPageLeaf;\r\n  };\r\n\r\n  private copyPDFDict = (originalDict: PDFDict): PDFDict => {\r\n    if (this.traversedObjects.has(originalDict)) {\r\n      return this.traversedObjects.get(originalDict) as PDFDict;\r\n    }\r\n\r\n    const clonedDict = originalDict.clone(this.dest);\r\n    this.traversedObjects.set(originalDict, clonedDict);\r\n\r\n    const entries = originalDict.entries();\r\n\r\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\r\n      const [key, value] = entries[idx];\r\n      clonedDict.set(key, this.copy(value));\r\n    }\r\n\r\n    return clonedDict;\r\n  };\r\n\r\n  private copyPDFArray = (originalArray: PDFArray): PDFArray => {\r\n    if (this.traversedObjects.has(originalArray)) {\r\n      return this.traversedObjects.get(originalArray) as PDFArray;\r\n    }\r\n\r\n    const clonedArray = originalArray.clone(this.dest);\r\n    this.traversedObjects.set(originalArray, clonedArray);\r\n\r\n    for (let idx = 0, len = originalArray.size(); idx < len; idx++) {\r\n      const value = originalArray.get(idx);\r\n      clonedArray.set(idx, this.copy(value));\r\n    }\r\n\r\n    return clonedArray;\r\n  };\r\n\r\n  private copyPDFStream = (originalStream: PDFStream): PDFStream => {\r\n    if (this.traversedObjects.has(originalStream)) {\r\n      return this.traversedObjects.get(originalStream) as PDFStream;\r\n    }\r\n\r\n    const clonedStream = originalStream.clone(this.dest);\r\n    this.traversedObjects.set(originalStream, clonedStream);\r\n\r\n    const entries = originalStream.dict.entries();\r\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\r\n      const [key, value] = entries[idx];\r\n      clonedStream.dict.set(key, this.copy(value));\r\n    }\r\n\r\n    return clonedStream;\r\n  };\r\n\r\n  private copyPDFIndirectObject = (ref: PDFRef): PDFRef => {\r\n    const alreadyMapped = this.traversedObjects.has(ref);\r\n\r\n    if (!alreadyMapped) {\r\n      const newRef = this.dest.nextRef();\r\n      this.traversedObjects.set(ref, newRef);\r\n\r\n      const dereferencedValue = this.src.lookup(ref);\r\n      if (dereferencedValue) {\r\n        const cloned = this.copy(dereferencedValue);\r\n        this.dest.assign(newRef, cloned);\r\n      }\r\n    }\r\n\r\n    return this.traversedObjects.get(ref) as PDFRef;\r\n  };\r\n}\r\n\r\nexport default PDFObjectCopier;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}